<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>ç­ç´šæŠ½çç³»çµ± (å…¨å¹³å°é€šç”¨ç‰ˆ)</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js"></script>

  <style>
    body {
      background-color: #1e1e1e;
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 10px;
      /* é˜²æ­¢æ‰‹æ©Ÿä¸‹æ‹‰é‡æ•´ */
      overscroll-behavior: none;
    }

    h1 { margin-bottom: 10px; font-size: 1.5rem; text-align: center;}

    .container {
      position: relative;
      width: 100%;
      max-width: 960px;
      /* è®“å®¹å™¨ç¶­æŒ 16:9 æ¯”ä¾‹ */
      aspect-ratio: 16/9;
      background-color: #000;
      border: 2px solid #333;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
    }

    /* é—œéµï¼šåŠ ä¸Š playsinline å±¬æ€§ä¸¦éš±è—åŸå§‹å½±ç‰‡ */
    video { 
      position: absolute; 
      visibility: hidden; 
      width: 100%; 
      height: 100%; 
    }
    
    canvas {
      width: 100%;
      height: 100%;
      /* é è¨­ä¸ç¿»è½‰ (å¾Œé¡é ­æ¨¡å¼)ï¼Œå¦‚æœæ˜¯å‰é¡é ­æˆ‘å€‘æœƒç”¨ JS æ§åˆ¶ */
      transform: scaleX(1); 
    }

    .controls {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }

    button {
      padding: 10px 20px;
      font-size: 1.1rem;
      cursor: pointer;
      background: linear-gradient(135deg, #007bff, #0056b3);
      color: white;
      border: none;
      border-radius: 50px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      /* ç¦æ­¢æ‰‹æ©Ÿä¸Šé¸å–æ–‡å­— */
      user-select: none; 
      -webkit-user-select: none;
    }

    button:active { transform: translateY(2px); }
    
    button:disabled { 
      background: #555; 
      color: #888;
      cursor: not-allowed; 
      box-shadow: none;
    }

    /* ç‰¹åˆ¥è¨­è¨ˆçµ¦ã€Œå•Ÿå‹•ã€æŒ‰éˆ•çš„æ¨£å¼ */
    #start-btn {
      background: linear-gradient(135deg, #28a745, #218838);
    }
    
    /* ç‰¹åˆ¥è¨­è¨ˆçµ¦ã€Œåˆ‡æ›é¡é ­ã€çš„æ¨£å¼ */
    #switch-cam-btn {
      background: linear-gradient(135deg, #6c757d, #5a6268);
    }

    #status { margin-top: 10px; color: #aaa; font-size: 0.9rem; text-align: center; }
    
    #winner-display {
      margin-top: 15px;
      font-size: 1.5rem;
      font-weight: bold;
      color: #ffd700;
      min-height: 40px;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
      text-align: center;
    }
  </style>
</head>
<body>

  <h1>ğŸ† ç­ç´šæŠ½çç³»çµ± (è¡Œå‹•ç‰ˆ)</h1>
  
  <div class="container">
    <video id="input_video" playsinline webkit-playsinline muted autoplay></video>
    <canvas id="output_canvas"></canvas>
  </div>

  <div id="status">è«‹æŒ‰ä¸‹ã€Œå•Ÿå‹•æ”å½±æ©Ÿã€</div>
  <div id="winner-display"></div>

  <div class="controls">
    <button id="start-btn">ğŸ“¸ å•Ÿå‹•æ”å½±æ©Ÿ</button>
    <button id="switch-cam-btn" style="display:none;">ğŸ”„ åˆ‡æ›å‰å¾Œé¡é ­</button>
    <button id="draw-btn" disabled>ğŸ² é–‹å§‹æŠ½ç</button>
  </div>

  <script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    
    const startBtn = document.getElementById('start-btn');
    const switchBtn = document.getElementById('switch-cam-btn');
    const drawBtn = document.getElementById('draw-btn');
    
    const statusText = document.getElementById('status');
    const winnerDisplay = document.getElementById('winner-display');

    let detectedFaces = []; 
    let isRolling = false;  
    let winnerIndex = -1;   
    
    // æ”å½±æ©Ÿæ§åˆ¶è®Šæ•¸
    let currentStream = null;
    let useFrontCamera = false; // é è¨­ä½¿ç”¨å¾Œé¡é ­ (æ‹å…¨ç­)
    let isCameraRunning = false;

    // --- MediaPipe è¨­å®š ---
    const faceDetection = new FaceDetection({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`;
      }
    });

    faceDetection.setOptions({
      model: 'full', // é è·é›¢æ¨¡å¼
      minDetectionConfidence: 0.5,
      selfieMode: false 
    });

    faceDetection.onResults(onResults);

    // --- æ ¸å¿ƒåŠŸèƒ½ï¼šå•Ÿå‹•æ”å½±æ©Ÿ (åŸç”Ÿ getUserMedia) ---
    async function startCamera() {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }

      statusText.innerText = "æ­£åœ¨è«‹æ±‚æ”å½±æ©Ÿæ¬Šé™...";

      // è¨­å®šé¡é ­åƒæ•¸
      const constraints = {
        audio: false,
        video: {
          facingMode: useFrontCamera ? "user" : "environment", // user=å‰é¡é ­, environment=å¾Œé¡é ­
          width: { ideal: 1280 }, // å˜—è©¦è«‹æ±‚é«˜ç•«è³ªï¼Œä½†ä¸å¼·åˆ¶ (æ‰‹æ©Ÿç›¸å®¹æ€§è¼ƒå¥½)
          height: { ideal: 720 }
        }
      };

      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        videoElement.srcObject = stream;
        
        // ç­‰å¾…å½±ç‰‡è¼‰å…¥å®Œæˆ
        videoElement.onloadedmetadata = () => {
          videoElement.play();
          isCameraRunning = true;
          statusText.innerText = "ç³»çµ±é‹ä½œä¸­ | ç­‰å¾…åµæ¸¬äººè‡‰...";
          startBtn.style.display = 'none'; // éš±è—å•Ÿå‹•æŒ‰éˆ•
          switchBtn.style.display = 'inline-block'; // é¡¯ç¤ºåˆ‡æ›æŒ‰éˆ•
          
          // æ ¹æ“šé¡é ­èª¿æ•´é¡åƒ (å‰é¡é ­è¦ç¿»è½‰ï¼Œå¾Œé¡é ­ä¸ç”¨)
          if (useFrontCamera) {
            canvasElement.style.transform = "scaleX(-1)";
          } else {
            canvasElement.style.transform = "scaleX(1)";
          }

          // é–‹å§‹å¾ªç’°åµæ¸¬
          detectLoop();
        };
      } catch (err) {
        console.error("æ”å½±æ©Ÿå•Ÿå‹•å¤±æ•—:", err);
        statusText.innerText = "éŒ¯èª¤ï¼šç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿ (è«‹ç¢ºèªæ¬Šé™æˆ–ç¶²å€æ˜¯å¦ç‚º HTTPS)";
        alert("ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿï¼\nè«‹ç¢ºèªï¼š\n1. ç¶²å€å¿…é ˆæ˜¯ HTTPS (Github Pages æˆ– ngrok)\n2. è«‹å…è¨±ç€è¦½å™¨ä½¿ç”¨ç›¸æ©Ÿ");
      }
    }

    // --- å¾ªç’°åµæ¸¬å‡½å¼ (å–ä»£åŸæœ¬çš„ Camera å·¥å…·) ---
    async function detectLoop() {
      if (!isCameraRunning) return;
      
      // ç¢ºä¿å½±ç‰‡æœ‰å¯¬é«˜æ‰å‚³é€
      if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
        // åŒæ­¥ Canvas å¤§å°èˆ‡å½±ç‰‡ä¸€è‡´ (é¿å…è®Šå½¢)
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        
        await faceDetection.send({image: videoElement});
      }
      
      requestAnimationFrame(detectLoop);
    }

    // --- ç¹ªåœ–èˆ‡é‚è¼¯ ---
    function onResults(results) {
      statusText.innerText = `ç³»çµ±é‹ä½œä¸­ | åµæ¸¬åˆ° ${results.detections.length} äºº`;
      
      if (!isRolling && results.detections.length > 0) {
        drawBtn.disabled = false;
      } else {
        drawBtn.disabled = true;
      }

      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      detectedFaces = results.detections;

      if (detectedFaces.length > 0) {
        detectedFaces.forEach((detection, index) => {
          const box = detection.boundingBox;
          const w = box.width * canvasElement.width;
          const h = box.height * canvasElement.height;
          const x = box.xCenter * canvasElement.width - (w / 2);
          const y = box.yCenter * canvasElement.height - (h / 2);

          let color = 'rgba(255, 255, 255, 0.5)'; 
          let lineWidth = 2;

          if (index === winnerIndex) {
            if (isRolling) {
              color = '#00CCFF';
              lineWidth = 5;
            } else {
              color = '#FF0033';
              lineWidth = 10;
            }
          }

          canvasCtx.save();
          canvasCtx.beginPath();
          canvasCtx.rect(x, y, w, h);
          canvasCtx.lineWidth = lineWidth;
          canvasCtx.strokeStyle = color;
          
          if (index === winnerIndex && !isRolling) {
            canvasCtx.shadowColor = "red";
            canvasCtx.shadowBlur = 20;
          }
          canvasCtx.stroke();
          canvasCtx.restore();

          if (index === winnerIndex && !isRolling) {
            drawGoldenExclamation(x, y, w, h);
          }
        });
      }
    }

    // ç¹ªè£½é©šå˜†è™Ÿç‰¹æ•ˆ
    function drawGoldenExclamation(x, y, w, h) {
      // å‹•æ…‹è¨ˆç®—å¤§å°ï¼Œé¿å…äººè‡‰å¤ªé æ™‚é©šå˜†è™Ÿå¤ªå¤§
      const scale = w / 200; // åŸºæº–ç¸®æ”¾
      const actualScale = Math.max(0.5, Math.min(scale, 1.5)); // é™åˆ¶ç¸®æ”¾ç¯„åœ

      const centerX = x + w / 2;
      const bottomY = y - (20 * actualScale); 
      
      const dotSize = 15 * actualScale;     
      const barWidth = 24 * actualScale;    
      const barHeight = 80 * actualScale;   

      const time = Date.now() / 200; 
      const glowIntensity = Math.abs(Math.sin(time)) * 20 + 10; 

      canvasCtx.save();
      canvasCtx.shadowColor = "#FFD700"; 
      canvasCtx.shadowBlur = glowIntensity; 
      canvasCtx.fillStyle = "#FFD700";   
      canvasCtx.strokeStyle = "#FFFFE0"; 
      canvasCtx.lineWidth = 3 * actualScale;

      const barX = centerX - barWidth / 2;
      const barY = bottomY - dotSize * 2 - (15 * actualScale) - barHeight; 
      roundRect(canvasCtx, barX, barY, barWidth, barHeight, 10 * actualScale, true, true);

      const dotY = bottomY - dotSize;
      canvasCtx.beginPath();
      canvasCtx.arc(centerX, dotY, dotSize, 0, Math.PI * 2);
      canvasCtx.fill();
      canvasCtx.stroke(); 
      canvasCtx.restore();
    }

    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof stroke === 'undefined') { stroke = true; }
      if (typeof radius === 'undefined') { radius = 5; }
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      if (fill) { ctx.fill(); }
      if (stroke) { ctx.stroke(); }
    }

    // --- æŒ‰éˆ•äº‹ä»¶ç¶å®š ---
    
    // 1. å•Ÿå‹•æŒ‰éˆ• (æ‰‹æ©Ÿå¿…é ˆæ‰‹å‹•é»æ“Š)
    startBtn.addEventListener('click', () => {
      startCamera();
    });

    // 2. åˆ‡æ›é¡é ­æŒ‰éˆ•
    switchBtn.addEventListener('click', () => {
      useFrontCamera = !useFrontCamera;
      startCamera(); // é‡æ–°å•Ÿå‹•ä»¥å¥—ç”¨æ–°é¡é ­
    });

    // 3. æŠ½çæŒ‰éˆ•
    drawBtn.addEventListener('click', () => {
      if (detectedFaces.length === 0) return;
      isRolling = true;
      drawBtn.disabled = true; // æŠ½çæ™‚ç¦æ­¢é‡è¤‡é»æ“Š
      winnerDisplay.innerText = "ğŸ² å‘½é‹è¼ªè½‰ä¸­...";
      winnerIndex = -1;
      let rollCount = 0;
      const maxRolls = 30; 
      const speed = 80;    
      const interval = setInterval(() => {
        winnerIndex = Math.floor(Math.random() * detectedFaces.length);
        rollCount++;
        if (rollCount >= maxRolls) {
          clearInterval(interval);
          isRolling = false; 
          drawBtn.disabled = false;
          winnerDisplay.innerText = "âœ¨âœ¨ å¤©é¸ä¹‹äººèª•ç”Ÿï¼ âœ¨âœ¨";
        }
      }, speed); 
    });

  </script>
</body>
</html>
