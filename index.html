<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>ç­ç´šæŠ½çç³»çµ± (å®šæ ¼ç‰¹å¯«ç‰ˆ)</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js"></script>

  <style>
    body {
      background-color: #1e1e1e;
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 10px;
      overscroll-behavior: none;
    }

    h1 { margin-bottom: 10px; font-size: 1.5rem; text-align: center;}

    .container {
      position: relative;
      width: 100%;
      max-width: 960px;
      aspect-ratio: 16/9;
      background-color: #000;
      border: 2px solid #333;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
    }

    video { 
      position: absolute; 
      visibility: hidden; 
      width: 100%; 
      height: 100%; 
    }
    
    canvas {
      width: 100%;
      height: 100%;
      transform: scaleX(1); 
    }

    .controls {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }

    button {
      padding: 10px 20px;
      font-size: 1.1rem;
      cursor: pointer;
      background: linear-gradient(135deg, #007bff, #0056b3);
      color: white;
      border: none;
      border-radius: 50px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      user-select: none; 
      -webkit-user-select: none;
    }

    button:active { transform: translateY(2px); }
    button:disabled { background: #555; color: #888; cursor: not-allowed; box-shadow: none; }

    #start-btn { background: linear-gradient(135deg, #28a745, #218838); }
    #reset-btn { background: linear-gradient(135deg, #dc3545, #c82333); display: none; } /* é è¨­éš±è— */

    #status { margin-top: 10px; color: #aaa; font-size: 0.9rem; text-align: center; }
    
    #winner-display {
      margin-top: 10px;
      font-size: 1.5rem;
      font-weight: bold;
      color: #ffd700;
      min-height: 30px;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
      text-align: center;
    }

    /* --- ç‰¹å¯«å½ˆçª—æ¨£å¼ --- */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: none; /* é è¨­éš±è— */
      justify-content: center;
      align-items: center;
      z-index: 999;
      animation: fadeIn 0.3s ease;
    }

    .modal-content {
      background: #2b2b2b;
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      border: 2px solid #ffd700;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
      max-width: 90%;
    }

    .modal-content h2 { color: #ffd700; margin: 0 0 15px 0; }

    #winner-canvas {
      border-radius: 10px;
      border: 3px solid white;
      margin-bottom: 15px;
      background: #000;
    }

    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  </style>
</head>
<body>

  <h1>ğŸ† ç­ç´šæŠ½çç³»çµ± (å®šæ ¼ç‰¹å¯«ç‰ˆ)</h1>
  
  <div class="container">
    <video id="input_video" playsinline webkit-playsinline muted autoplay></video>
    <canvas id="output_canvas"></canvas>
  </div>

  <div id="status">è«‹æŒ‰ä¸‹ã€Œå•Ÿå‹•æ”å½±æ©Ÿã€</div>
  <div id="winner-display"></div>

  <div class="controls">
    <button id="start-btn">ğŸ“¸ å•Ÿå‹•é«˜ç•«è³ªæ”å½±æ©Ÿ</button>
    <button id="draw-btn" disabled>ğŸ² å®šæ ¼ä¸¦æŠ½ç</button>
    <button id="reset-btn">ğŸ”„ æ¸…ç©ºä¸¦é‡ç½®</button>
  </div>

  <div class="modal-overlay" id="winner-modal">
    <div class="modal-content">
      <h2>âœ¨ æ­å–œä¸­çï¼ âœ¨</h2>
      <canvas id="winner-canvas"></canvas>
      <br>
      <button onclick="closeModal()">é—œé–‰è¦–çª—</button>
    </div>
  </div>

  <script>
    // --- DOM å…ƒç´  ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d', { willReadFrequently: true });
    
    const startBtn = document.getElementById('start-btn');
    const drawBtn = document.getElementById('draw-btn');
    const resetBtn = document.getElementById('reset-btn');
    const statusText = document.getElementById('status');
    const winnerDisplay = document.getElementById('winner-display');
    const winnerModal = document.getElementById('winner-modal');
    const winnerCanvas = document.getElementById('winner-canvas');
    const winnerCtx = winnerCanvas.getContext('2d');

    // --- ç‹€æ…‹è®Šæ•¸ ---
    let detectedFaces = [];      // å³æ™‚åµæ¸¬åˆ°çš„äººè‡‰
    let frozenFaces = [];        // å®šæ ¼ç•¶ä¸‹çš„äººè‡‰æ•¸æ“š
    let isRolling = false;       // æ˜¯å¦æ­£åœ¨è·‘æŠ½çå‹•ç•«
    let isFrozen = false;        // æ˜¯å¦è™•æ–¼å®šæ ¼ç‹€æ…‹
    let winnerIndex = -1;        
    let currentStream = null;
    let isCameraRunning = false;
    let snapshotImage = null;    // å­˜å„²å®šæ ¼æ™‚çš„ç•«é¢

    // --- 1. MediaPipe è¨­å®š (æ•æ„Ÿåº¦èª¿æ•´å€) ---
    const faceDetection = new FaceDetection({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`
    });

    faceDetection.setOptions({
      model: 'full', // é è·é›¢æ¨¡å¼
      // [æ•™å­¸] é€™è£¡å°±æ˜¯æ•æ„Ÿåº¦ï¼
      // å¦‚æœè¦ºå¾—å®¹æ˜“èª¤åˆ¤(æŠŠæ™‚é˜ç•¶äººè‡‰)ï¼Œè«‹æŠŠ 0.3 æ”¹æˆ 0.5 æˆ– 0.6
      // å¦‚æœè¦ºå¾—å¤ªé æŠ“ä¸åˆ°äººï¼Œè«‹ç¶­æŒ 0.3 æˆ–æ”¹ 0.2
      minDetectionConfidence: 0.5, 
      selfieMode: false 
    });

    faceDetection.onResults(onResults);

    // --- 2. å•Ÿå‹•æ”å½±æ©Ÿ ---
    async function startCamera() {
      if (currentStream) return;

      statusText.innerText = "æ­£åœ¨è«‹æ±‚é«˜ç•«è³ªè¨Šè™Ÿ...";
      const constraints = {
        audio: false,
        video: {
          facingMode: "environment", // é è¨­å¾Œé¡é ­
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        }
      };

      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        videoElement.srcObject = stream;
        
        videoElement.onloadedmetadata = () => {
          videoElement.play();
          isCameraRunning = true;
          statusText.innerText = `ç³»çµ±å°±ç·’ | è§£æåº¦: ${videoElement.videoWidth}x${videoElement.videoHeight}`;
          startBtn.style.display = 'none';
          detectLoop();
        };
      } catch (err) {
        console.error(err);
        alert("ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿ");
      }
    }

    // --- 3. åµæ¸¬èˆ‡ç¹ªåœ–è¿´åœˆ ---
    async function detectLoop() {
      // åªæœ‰åœ¨ã€Œéå®šæ ¼ã€ç‹€æ…‹ä¸‹ï¼Œæ‰æŒçºŒé€å‡ºç•«é¢çµ¦ AI åµæ¸¬
      // é€™æ¨£å¯ä»¥çœæ•ˆèƒ½ï¼Œä¸¦ç¢ºä¿å®šæ ¼å¾Œæ•¸æ“šä¸è®Š
      if (isCameraRunning && !isFrozen) {
        if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
          canvasElement.width = videoElement.videoWidth;
          canvasElement.height = videoElement.videoHeight;
          await faceDetection.send({image: videoElement});
        }
      }
      
      // å¦‚æœæ˜¯å®šæ ¼ç‹€æ…‹ï¼Œæˆ‘å€‘éœ€è¦æ‰‹å‹•å‘¼å«ç¹ªåœ–ï¼Œå› ç‚º AI ä¸æœƒå†è§¸ç™¼ onResults
      if (isFrozen) {
        drawFrozenFrame();
      }

      requestAnimationFrame(detectLoop);
    }

    // --- 4. å³æ™‚åµæ¸¬å›èª¿ (Live Mode) ---
    function onResults(results) {
      if (isFrozen) return; // å¦‚æœå·²ç¶“å®šæ ¼ï¼Œå¿½ç•¥æ–°çš„ AI çµæœ

      // æ›´æ–°å…¨åŸŸè®Šæ•¸
      detectedFaces = results.detections;
      
      // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
      if (detectedFaces.length > 0) {
        drawBtn.disabled = false;
        statusText.innerText = `å³æ™‚ç•«é¢ | åµæ¸¬äººæ•¸: ${detectedFaces.length}`;
      } else {
        drawBtn.disabled = true;
        statusText.innerText = `æœå°‹äººè‡‰ä¸­...`;
      }

      // ç¹ªè£½ç•«é¢
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
      drawBoxes(detectedFaces);
    }

    // --- 5. å®šæ ¼ç¹ªåœ– (Frozen Mode) ---
    function drawFrozenFrame() {
      // 1. ç•«å‡ºå®šæ ¼çš„é‚£å¼µç…§ç‰‡
      if (snapshotImage) {
        canvasCtx.drawImage(snapshotImage, 0, 0);
      }
      // 2. ç•«å‡ºå®šæ ¼æ™‚çš„äººè‡‰æ¡† (ä½¿ç”¨ frozenFaces)
      drawBoxes(frozenFaces);
    }

    // --- 6. ç•«æ¡†æ¡†çš„å…±ç”¨å‡½å¼ ---
    function drawBoxes(faces) {
      if (!faces || faces.length === 0) return;

      faces.forEach((detection, index) => {
        const box = detection.boundingBox;
        const w = box.width * canvasElement.width;
        const h = box.height * canvasElement.height;
        const x = box.xCenter * canvasElement.width - (w / 2);
        const y = box.yCenter * canvasElement.height - (h / 2);

        let color = 'rgba(255, 255, 255, 0.4)';
        let lineWidth = Math.max(2, w / 60);

        // æŠ½çé¸ä¸­æ•ˆæœ
        if (index === winnerIndex) {
          if (isRolling) {
            color = '#00CCFF'; // è·‘é¦¬ç‡ˆé¡è‰²
            lineWidth *= 2;
          } else {
            color = '#FF0033'; // ä¸­çé¡è‰²
            lineWidth *= 3;
          }
        }

        canvasCtx.save();
        canvasCtx.beginPath();
        canvasCtx.rect(x, y, w, h);
        canvasCtx.lineWidth = lineWidth;
        canvasCtx.strokeStyle = color;

        if (index === winnerIndex && !isRolling && isFrozen) {
          canvasCtx.shadowColor = "red";
          canvasCtx.shadowBlur = 20;
        }
        canvasCtx.stroke();
        canvasCtx.restore();

        // ç•«é©šå˜†è™Ÿ (åªåœ¨ä¸­çå¾Œé¡¯ç¤º)
        if (index === winnerIndex && !isRolling && isFrozen) {
          drawGoldenExclamation(x, y, w, h);
        }
      });
    }

    // --- 7. æŒ‰éˆ•é‚è¼¯ ---

    // [æŠ½ç]
    drawBtn.addEventListener('click', () => {
      if (detectedFaces.length === 0) return;

      // === æ­¥é©Ÿ A: å®šæ ¼ ===
      isFrozen = true;
      // å‚™ä»½ç•¶ä¸‹çš„äººè‡‰æ•¸æ“šï¼Œä¹‹å¾Œå‹•ç•«éƒ½åªç”¨é€™çµ„æ•¸æ“š
      frozenFaces = [...detectedFaces]; 
      
      // å»ºç«‹æˆªåœ– (Snapshot)
      snapshotImage = new Image();
      snapshotImage.src = canvasElement.toDataURL(); // æŠŠç•¶ä¸‹ Canvas å­˜æˆåœ–ç‰‡

      // === æ­¥é©Ÿ B: UI è®Šæ›´ ===
      drawBtn.style.display = 'none';   // éš±è—æŠ½çéˆ•
      resetBtn.style.display = 'inline-block'; // é¡¯ç¤ºé‡ç½®éˆ•
      statusText.innerText = "ğŸ”’ ç•«é¢å·²é–å®š | æŠ½çé€²è¡Œä¸­...";

      // === æ­¥é©Ÿ C: åŸ·è¡ŒæŠ½çå‹•ç•« ===
      isRolling = true;
      winnerDisplay.innerText = "ğŸ² å‘½é‹è¼ªè½‰ä¸­...";
      winnerIndex = -1;
      
      let rollCount = 0;
      const maxRolls = 30;
      const speed = 80;

      const interval = setInterval(() => {
        // åœ¨ frozenFaces è£¡éš¨æ©Ÿè·³
        winnerIndex = Math.floor(Math.random() * frozenFaces.length);
        rollCount++;

        if (rollCount >= maxRolls) {
          clearInterval(interval);
          finishLottery(); // çµæŸæŠ½ç
        }
      }, speed);
    });

    // [é‡ç½®]
    resetBtn.addEventListener('click', () => {
      resetSystem();
    });

    function finishLottery() {
      isRolling = false;
      winnerDisplay.innerText = "âœ¨âœ¨ å¤©é¸ä¹‹äººèª•ç”Ÿï¼ âœ¨âœ¨";
      
      // å»¶é²ä¸€é»é»å†é¡¯ç¤ºç‰¹å¯«ï¼Œè®“å¤§å®¶å…ˆçœ‹åˆ°æ¡†æ¡†è®Šç´…
      setTimeout(() => {
        showWinnerDetail(winnerIndex);
      }, 600);
    }

    function resetSystem() {
      isFrozen = false;
      isRolling = false;
      winnerIndex = -1;
      frozenFaces = [];
      snapshotImage = null;
      winnerDisplay.innerText = "";
      
      drawBtn.style.display = 'inline-block';
      drawBtn.disabled = false;
      resetBtn.style.display = 'none';
      closeModal();
      
      statusText.innerText = "å·²é‡ç½® | ç¹¼çºŒåµæ¸¬ä¸­...";
    }

    // --- 8. ç‰¹å¯«è¦–çª—é‚è¼¯ ---
    function showWinnerDetail(index) {
      if (index < 0 || index >= frozenFaces.length) return;

      const detection = frozenFaces[index];
      const box = detection.boundingBox;
      
      // è¨ˆç®—æˆªåœ–å€åŸŸ (ç¨å¾®æ¯”äººè‡‰æ¡†å¤§ä¸€é»ï¼Œæ‰ä¸æœƒåªæœ‰è‡‰æ²’æœ‰é ­é«®)
      const padding = 0.5; // æ“´å¤§ 50%
      let w = box.width * canvasElement.width;
      let h = box.height * canvasElement.height;
      let x = box.xCenter * canvasElement.width - (w / 2);
      let y = box.yCenter * canvasElement.height - (h / 2);

      // æ“´å¤§ç¯„åœ
      const extW = w * (1 + padding);
      const extH = h * (1 + padding);
      const extX = x - (w * padding) / 2;
      const extY = y - (h * padding) / 2;

      // è¨­å®šç‰¹å¯« Canvas å¤§å° (ä¾‹å¦‚å›ºå®šå¯¬ 300pxï¼Œé«˜ç­‰æ¯”ä¾‹)
      const targetW = 300;
      const targetH = targetW * (h / w);
      winnerCanvas.width = targetW;
      winnerCanvas.height = targetH;

      // å¾åŸæœ¬çš„ snapshot å‰ªè£å‡ºé‚£å€‹äººçš„è‡‰
      winnerCtx.drawImage(
        snapshotImage, 
        extX, extY, extW, extH, // ä¾†æºç¯„åœ
        0, 0, targetW, targetH  // ç›®æ¨™ç¯„åœ
      );

      // é¡¯ç¤ºè¦–çª—
      winnerModal.style.display = 'flex';
    }

    function closeModal() {
      winnerModal.style.display = 'none';
    }

    // å•Ÿå‹•éˆ•ç›£è½
    startBtn.addEventListener('click', startCamera);

    // --- è¼”åŠ©ç¹ªåœ– (é©šå˜†è™Ÿèˆ‡åœ“è§’) ---
    function drawGoldenExclamation(x, y, w, h) {
      const scale = w / 150; 
      const actualScale = Math.max(0.4, scale); 
      const centerX = x + w / 2;
      const bottomY = y - (20 * actualScale); 
      const dotSize = 15 * actualScale;     
      const barWidth = 24 * actualScale;    
      const barHeight = 80 * actualScale;   
      const time = Date.now() / 200; 
      const glowIntensity = Math.abs(Math.sin(time)) * 20 + 10; 

      canvasCtx.save();
      canvasCtx.shadowColor = "#FFD700"; 
      canvasCtx.shadowBlur = glowIntensity; 
      canvasCtx.fillStyle = "#FFD700";   
      canvasCtx.strokeStyle = "#FFFFE0"; 
      canvasCtx.lineWidth = 3 * actualScale;

      const barX = centerX - barWidth / 2;
      const barY = bottomY - dotSize * 2 - (15 * actualScale) - barHeight; 
      roundRect(canvasCtx, barX, barY, barWidth, barHeight, 10 * actualScale, true, true);
      const dotY = bottomY - dotSize;
      canvasCtx.beginPath();
      canvasCtx.arc(centerX, dotY, dotSize, 0, Math.PI * 2);
      canvasCtx.fill();
      canvasCtx.stroke(); 
      canvasCtx.restore();
    }

    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof stroke === 'undefined') { stroke = true; }
      if (typeof radius === 'undefined') { radius = 5; }
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      if (fill) { ctx.fill(); }
      if (stroke) { ctx.stroke(); }
    }
  </script>
</body>
</html>
