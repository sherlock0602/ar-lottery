<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>ç­ç´šæŠ½çç³»çµ± (è‡ªå‹•è¿½è¹¤ç‰ˆ)</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/face_detection.js"></script>

  <style>
    body {
      background-color: #1e1e1e;
      color: white;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 10px;
      overscroll-behavior: none;
      user-select: none;
      -webkit-user-select: none;
    }

    h1 { margin-bottom: 5px; font-size: 1.4rem; text-align: center;}

    .container {
      position: relative;
      width: 100%;
      max-width: 960px;
      aspect-ratio: 16/9;
      background-color: #000;
      border: 2px solid #333;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
      cursor: crosshair; 
    }

    video { 
      position: absolute; 
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover;
      z-index: -1;
      opacity: 0;
    }
    
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .controls {
      margin-top: 15px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      width: 100%;
      max-width: 600px;
    }

    .zoom-control {
      width: 100%;
      display: none; 
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-bottom: 10px;
      background: #333;
      padding: 10px;
      border-radius: 50px;
    }
    
    .zoom-control label { font-size: 0.9rem; color: #ffd700; }
    
    input[type=range] {
      width: 70%;
      accent-color: #ffd700;
      cursor: pointer;
    }

    button {
      padding: 12px 24px;
      font-size: 1.1rem;
      cursor: pointer;
      background: linear-gradient(135deg, #007bff, #0056b3);
      color: white;
      border: none;
      border-radius: 50px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }

    button:active { transform: translateY(2px); }
    button:disabled { background: #555; color: #888; cursor: not-allowed; box-shadow: none; }

    #start-btn { background: linear-gradient(135deg, #28a745, #218838); }
    #switch-cam-btn { background: linear-gradient(135deg, #6c757d, #5a6268); }
    #undo-btn { background: linear-gradient(135deg, #fd7e14, #e67e22); display: none; }
    #reset-btn { background: linear-gradient(135deg, #dc3545, #c82333); display: none; }

    #status { margin-top: 10px; color: #aaa; font-size: 0.9rem; text-align: center; }
    
    #winner-display {
      margin-top: 5px;
      font-size: 1.5rem;
      font-weight: bold;
      color: #ffd700;
      min-height: 30px;
      text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
      text-align: center;
    }

    .modal-overlay {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 999;
      animation: fadeIn 0.3s ease;
    }

    .modal-content {
      background: #2b2b2b;
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      border: 2px solid #ffd700;
      box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
      max-width: 90%;
    }
    
    .modal-content h2 { color: #ffd700; margin-bottom: 15px; }

    #winner-canvas {
      border-radius: 10px;
      border: 3px solid white;
      margin-bottom: 15px;
      background: #000;
      max-width: 100%;
      height: auto;
    }

    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
  </style>
</head>
<body>

  <h1>ğŸ† ç­ç´šæŠ½çç³»çµ± (è‡ªå‹•è¿½è¹¤ç‰ˆ)</h1>
  
  <div class="container" id="canvas-container">
    <video id="input_video" playsinline webkit-playsinline muted autoplay></video>
    <canvas id="output_canvas"></canvas>
  </div>

  <div id="status">è«‹æŒ‰ä¸‹ã€Œå•Ÿå‹•ç›¸æ©Ÿã€</div>
  <div id="winner-display"></div>

  <div class="controls">
    <div class="zoom-control" id="zoom-area">
      <label>ğŸ” é è·æ”¾å¤§:</label>
      <input type="range" id="zoom-slider" min="1" max="5" step="0.1" value="1">
    </div>

    <button id="start-btn">ğŸ“¸ å•Ÿå‹•ç›¸æ©Ÿ</button>
    <button id="switch-cam-btn" style="display:none;">ğŸ”„ åˆ‡æ›é¡é ­</button>
    <button id="undo-btn">â†©ï¸ æ’¤éŠ·æ‰‹å‹•</button>
    <button id="draw-btn" disabled>ğŸ² å®šæ ¼ä¸¦æŠ½ç</button>
    <button id="reset-btn">ğŸ”„ é‡ç½®</button>
  </div>

  <div class="modal-overlay" id="winner-modal">
    <div class="modal-content">
      <h2>âœ¨ å¹¸é‹å…’ç‰¹å¯« âœ¨</h2>
      <canvas id="winner-canvas"></canvas>
      <br>
      <button onclick="closeModal()">é—œé–‰è¦–çª—</button>
    </div>
  </div>

  <script>
    // --- æ ¸å¿ƒè®Šæ•¸ ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    // willReadFrequently å„ªåŒ– canvas è®€å–æ•ˆèƒ½ (å°è¿½è¹¤å¾ˆé‡è¦)
    const canvasCtx = canvasElement.getContext('2d', { willReadFrequently: true });
    
    const startBtn = document.getElementById('start-btn');
    const switchBtn = document.getElementById('switch-cam-btn');
    const drawBtn = document.getElementById('draw-btn');
    const resetBtn = document.getElementById('reset-btn');
    const undoBtn = document.getElementById('undo-btn');
    const statusText = document.getElementById('status');
    const winnerDisplay = document.getElementById('winner-display');
    const winnerModal = document.getElementById('winner-modal');
    const winnerCanvas = document.getElementById('winner-canvas');
    const winnerCtx = winnerCanvas.getContext('2d');
    const zoomArea = document.getElementById('zoom-area');
    const zoomSlider = document.getElementById('zoom-slider');

    let detectedFaces = []; 
    let manualFaces = [];   
    let frozenFaces = [];   
    let isRolling = false;       
    let isFrozen = false;        
    let winnerIndex = -1;        
    let currentStream = null;
    let isCameraRunning = false;
    let snapshotImage = null;
    let useFrontCamera = false; 
    let isModelLoaded = false;  
    let videoTrack = null;
    let zoomCap = null;

    // å‹•ç•«ç›¸é—œ
    let isShooting = false;
    let arrowProgress = 0;
    let arrowStart = {x:0, y:0};
    let arrowTarget = {x:0, y:0};
    let explosionFrame = 0;

    // MediaPipe
    const faceDetection = new FaceDetection({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_detection/${file}`
    });

    faceDetection.setOptions({
      model: 'full', 
      minDetectionConfidence: 0.3, 
      selfieMode: false 
    });

    faceDetection.onResults(onResults);

    // --- [æ–°å¢] æ‰‹å‹•é»æ“Š + åˆå§‹åŒ–è¿½è¹¤ç‰¹å¾µ ---
    canvasElement.addEventListener('click', (event) => {
      if (!isCameraRunning || isFrozen) return;

      const rect = canvasElement.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;

      // æ›ç®—å› Canvas åº§æ¨™ (å› ç‚º CSS å¯èƒ½æœƒç¸®æ”¾)
      const scaleX = canvasElement.width / rect.width;
      const scaleY = canvasElement.height / rect.height;
      
      let realX = clickX * scaleX;
      let realY = clickY * scaleY;

      // é è¨­æ¡†å¤§å° (ç´„ 80x120 åƒç´ ï¼Œè¦–è§£æåº¦è€Œå®š)
      const w = canvasElement.width * 0.05;
      const h = canvasElement.height * 0.08;
      
      // ç¢ºä¿æ¡†ä¸æœƒè¶…å‡ºé‚Šç•Œ
      const x = Math.max(0, Math.min(canvasElement.width - w, realX - w/2));
      const y = Math.max(0, Math.min(canvasElement.height - h, realY - h/2));

      // æˆªå–ç‰¹å¾µåœ– (Template) ç”¨æ–¼è¿½è¹¤
      // æˆ‘å€‘åªå–ä¸­é–“ä¸€å°å¡Šç•¶ç‰¹å¾µï¼Œæ¸›å°‘é‹ç®—é‡
      const templateSize = 20; // å– 20x20 åƒç´ ç•¶ç‰¹å¾µ
      const tX = x + w/2 - templateSize/2;
      const tY = y + h/2 - templateSize/2;
      
      const templateData = canvasCtx.getImageData(tX, tY, templateSize, templateSize);

      // å„²å­˜æ‰‹å‹•æ¡†è³‡è¨Š
      const fakeFace = {
        x: x,          // çµ•å°åº§æ¨™
        y: y,
        w: w,
        h: h,
        template: templateData, // ç”¨æ–¼è¿½è¹¤çš„å½±åƒæ•¸æ“š
        lastTrackX: tX,         // ä¸Šä¸€æ¬¡ç‰¹å¾µçš„ä½ç½®
        lastTrackY: tY,
        isManual: true,
        lostCount: 0            // è·Ÿä¸Ÿè¨ˆæ•¸å™¨
      };

      manualFaces.push(fakeFace);
      updateStatus();
      
      if (manualFaces.length > 0) {
        undoBtn.style.display = 'inline-block';
      }
    });

    undoBtn.addEventListener('click', () => {
      manualFaces.pop(); 
      if (manualFaces.length === 0) {
        undoBtn.style.display = 'none';
      }
      updateStatus();
    });

    // --- [æ–°å¢] æ ¸å¿ƒè¿½è¹¤æ¼”ç®—æ³• (Template Matching) ---
    function trackManualFaces() {
      // åªæœ‰éå®šæ ¼ç‹€æ…‹ä¸‹æ‰éœ€è¦è¿½è¹¤
      if (!isCameraRunning || isFrozen || manualFaces.length === 0) return;

      const searchRadius = 25; // æœå°‹åŠå¾‘ (å¤ªå¤§ä¼šæ…¢ï¼Œå¤ªå°æœƒè·Ÿä¸Ÿ)
      const templateSize = 20; 

      manualFaces.forEach(face => {
        // å¦‚æœè·Ÿä¸Ÿå¤ªä¹…ï¼Œå°±æ”¾æ£„è¿½è¹¤ï¼Œåœåœ¨åŸåœ°
        if (face.lostCount > 10) return;

        // å®šç¾©æœå°‹ç¯„åœ (åœ¨å‰ä¸€æ¬¡ä½ç½®çš„å‘¨åœæ‰¾)
        let startX = Math.max(0, face.lastTrackX - searchRadius);
        let startY = Math.max(0, face.lastTrackY - searchRadius);
        let endX = Math.min(canvasElement.width - templateSize, face.lastTrackX + searchRadius);
        let endY = Math.min(canvasElement.height - templateSize, face.lastTrackY + searchRadius);

        // å–å¾—æœå°‹ç¯„åœçš„å½±åƒ
        const searchWidth = endX - startX;
        const searchHeight = endY - startY;
        
        if (searchWidth <= 0 || searchHeight <= 0) return;

        const searchData = canvasCtx.getImageData(startX, startY, searchWidth, searchHeight);
        const templ = face.template.data;
        const scene = searchData.data;

        let minDiff = Infinity;
        let bestX = 0;
        let bestY = 0;

        // æƒææ¯ä¸€å€‹å¯èƒ½çš„é» (ç°¡å–®æš´åŠ›æ³•)
        // å„ªåŒ–ï¼šæ­¥é•·è¨­ç‚º 2 (è·³è‘—æƒæ)ï¼ŒçŠ§ç‰²ä¸€é»ç²¾åº¦æ›å– 4å€ é€Ÿåº¦
        for (let y = 0; y <= searchHeight - templateSize; y += 2) {
          for (let x = 0; x <= searchWidth - templateSize; x += 2) {
            
            let diff = 0;
            // æ¯”å°åƒç´ å·®ç•° (Sum of Absolute Differences)
            // å„ªåŒ–ï¼šåªæ¯”å°ç¶ è‰²é€šé“ (Green Channel)ï¼Œäººçœ¼æœ€æ•æ„Ÿï¼Œä¸”æ•ˆèƒ½çœ 2/3
            for (let i = 0; i < templateSize * templateSize; i++) {
               // åƒç´ ç´¢å¼•è½‰æ›
               const tIdx = i * 4 + 1; // Green
               const sIdx = ((y + Math.floor(i/templateSize)) * searchWidth + (x + i%templateSize)) * 4 + 1;
               
               diff += Math.abs(templ[tIdx] - scene[sIdx]);
               
               // ææ—©æ”¾æ£„ï¼šå¦‚æœå·®ç•°å·²ç¶“å¤ªå¤§ï¼Œå°±ä¸ç”¨æ¯”å®Œäº†
               if (diff > minDiff) break;
            }

            if (diff < minDiff) {
              minDiff = diff;
              bestX = x;
              bestY = y;
            }
          }
        }

        // é–¾å€¼åˆ¤æ–·ï¼šå¦‚æœå·®ç•°å¤ªå¤§ï¼Œä»£è¡¨æ ¹æœ¬æ²’æ‰¾åˆ°åƒçš„
        if (minDiff < 30000) { 
           // æ‰¾åˆ°äº†ï¼æ›´æ–°ä½ç½®
           const moveX = (startX + bestX) - face.lastTrackX;
           const moveY = (startX + bestY) - face.lastTrackY; // bug fix
           const correctMoveY = (startY + bestY) - face.lastTrackY;

           face.lastTrackX = startX + bestX;
           face.lastTrackY = startY + bestY;
           
           // æ›´æ–°æ¡†æ¡†ä½ç½® (è®“æ¡†æ¡†è·Ÿè‘—ç‰¹å¾µè·‘)
           face.x += moveX;
           face.y += correctMoveY;
           face.lostCount = 0;
        } else {
           face.lostCount++;
        }
      });
    }

    async function startCamera() {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }
      zoomArea.style.display = 'none';
      statusText.innerText = "æ­£åœ¨å•Ÿå‹•ç›¸æ©Ÿ (è«‹æ±‚é«˜ç•«è³ª)...";

      const constraints = {
        audio: false,
        video: {
          facingMode: useFrontCamera ? "user" : "environment",
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        }
      };

      try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        videoTrack = stream.getVideoTracks()[0];
        
        const capabilities = videoTrack.getCapabilities();
        if (capabilities.zoom) {
          zoomCap = capabilities.zoom;
          zoomSlider.min = zoomCap.min;
          zoomSlider.max = zoomCap.max;
          zoomSlider.step = zoomCap.step;
          zoomSlider.value = zoomCap.min;
          zoomArea.style.display = 'flex';
          statusText.innerText = "æ”¯æ´ç¡¬é«”è®Šç„¦ï¼";
        }
        
        videoElement.onloadedmetadata = () => {
          videoElement.play();
          isCameraRunning = true;
          startBtn.style.display = 'none';
          switchBtn.style.display = 'inline-block';
          updateStatus();
          
          if (useFrontCamera) {
            canvasElement.style.transform = "scaleX(-1)";
          } else {
            canvasElement.style.transform = "scaleX(1)";
          }
          detectLoop();
        };
        videoElement.srcObject = stream;
      } catch (err) {
        console.error("ç›¸æ©ŸéŒ¯èª¤:", err);
        alert("ç„¡æ³•å•Ÿå‹•ç›¸æ©Ÿï¼Œè«‹é‡æ•´é é¢ã€‚");
      }
    }

    zoomSlider.addEventListener('input', () => {
      if (videoTrack && zoomCap) {
        videoTrack.applyConstraints({ advanced: [{ zoom: parseFloat(zoomSlider.value) }] });
      }
    });

    async function detectLoop() {
      if (!isCameraRunning) return;
      
      if (videoElement.videoWidth > 0) {
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;

        // 1. ç¹ªè£½åŸå§‹ç•«é¢ (ç‚ºäº†çµ¦ getImageData å–æ¨£)
        if (!isFrozen) {
           canvasCtx.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
           
           // 2. åŸ·è¡Œæ‰‹å‹•è¿½è¹¤ (åœ¨ MediaPipe ä¹‹å‰åŸ·è¡Œï¼Œåˆ©ç”¨å‰›ç•«å¥½çš„ç•«é¢)
           trackManualFaces();
           
           // 3. åŸ·è¡Œ AI åµæ¸¬
           await faceDetection.send({image: videoElement});
        }
      }
      
      // å®šæ ¼æ¨¡å¼
      if (isFrozen) {
        drawFrozenFrame();
      }

      requestAnimationFrame(detectLoop);
    }

    function onResults(results) {
      isModelLoaded = true; 
      if (isFrozen) return; 

      detectedFaces = results.detections;
      
      // åˆä½µé¡¯ç¤º (è½‰æ› AI æ ¼å¼ èˆ‡ æ‰‹å‹•æ ¼å¼)
      // AI æ ¼å¼éœ€è¦è½‰æ›æˆçµ•å°åƒç´ åº§æ¨™ä»¥ä¾¿ drawBoxes çµ±ä¸€è™•ç†
      const aiFacesFormatted = detectedFaces.map(d => {
         const box = d.boundingBox;
         return {
            x: box.xCenter * canvasElement.width - (box.width * canvasElement.width / 2),
            y: box.yCenter * canvasElement.height - (box.height * canvasElement.height / 2),
            w: box.width * canvasElement.width,
            h: box.height * canvasElement.height,
            isManual: false
         };
      });

      const allFaces = [...aiFacesFormatted, ...manualFaces];

      updateStatus(allFaces.length);
      
      // é‡ç¹ªç•«é¢ (å› ç‚º trackManualFaces è®€å–éåƒç´ ï¼Œå¯èƒ½æœƒå½±éŸ¿ï¼Œæ‰€ä»¥é€™è£¡é‡ç•«ä¸€æ¬¡æœ€ä¹¾æ·¨)
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
      
      drawBoxes(allFaces);
    }

    function updateStatus(count = 0) {
      if (count === 0) {
        count = detectedFaces.length + manualFaces.length;
      }
      if (isCameraRunning && !isFrozen) {
        const resText = `${videoElement.videoWidth}x${videoElement.videoHeight}`;
        if (count > 0) {
           drawBtn.disabled = false;
           drawBtn.style.display = 'inline-block';
           statusText.innerText = `æº–å‚™å°±ç·’ | ç•«è³ª: ${resText} | ç¸½äººæ•¸: ${count} (æ‰‹å‹•: ${manualFaces.length})`;
        } else {
           drawBtn.disabled = true;
           statusText.innerText = `é»æ“Šç•«é¢æ‰‹å‹•è¿½è¹¤ | ç•«è³ª: ${resText}`;
        }
      }
    }

    function drawFrozenFrame() {
      if (snapshotImage) {
        canvasCtx.drawImage(snapshotImage, 0, 0);
      }
      // å®šæ ¼æ™‚ï¼Œå°‡æ‰€æœ‰è‡‰è½‰æ›æˆçµ±ä¸€æ ¼å¼ç¹ªè£½
      const aiFacesFormatted = frozenFaces.filter(f => !f.isManual).map(d => {
         // æ³¨æ„ï¼šé€™è£¡ frozenFaces è£¡å¯èƒ½æ··é›œäº† AI åŸå§‹æ•¸æ“šå’Œæ‰‹å‹•æ•¸æ“š
         // å¦‚æœæ˜¯ AI åŸå§‹æ•¸æ“š (æœ‰ boundingBox å±¬æ€§)
         if(d.boundingBox) {
            const box = d.boundingBox;
            return {
                x: box.xCenter * canvasElement.width - (box.width * canvasElement.width / 2),
                y: box.yCenter * canvasElement.height - (box.height * canvasElement.height / 2),
                w: box.width * canvasElement.width,
                h: box.height * canvasElement.height,
                isManual: false
            };
         }
         return d; // å·²ç¶“æ˜¯æ‰‹å‹•æ ¼å¼
      });
      
      // éæ¿¾æ‰å·²ç¶“è½‰æ›éçš„ï¼Œé¿å…é‡è¤‡
      const manualFacesFrozen = frozenFaces.filter(f => f.isManual);
      const facesToDraw = [...aiFacesFormatted, ...manualFacesFrozen];

      drawBoxes(facesToDraw);
      
      if (isShooting) {
        updateAndDrawArrow(facesToDraw);
      }
    }

    function drawBoxes(faces) {
      if (!faces) return;
      faces.forEach((face, index) => {
        let color = 'rgba(255, 255, 255, 0.4)';
        if (face.isManual) {
            // æ‰‹å‹•æ¡†é¡¯ç¤ºç‚ºç¶ è‰²ï¼Œä¸¦ä¸”å¦‚æœè·Ÿä¸Ÿäº†é¡¯ç¤ºç‚ºé»ƒè‰²
            color = face.lostCount > 5 ? 'rgba(255, 255, 0, 0.6)' : 'rgba(0, 255, 127, 0.6)';
        }

        let lineWidth = Math.max(2, face.w / 80);

        if (index === winnerIndex) {
          if (isRolling) {
            color = '#00CCFF'; 
            lineWidth *= 2;
          } else {
            color = '#FF0033'; 
            lineWidth *= 3;
          }
        }

        canvasCtx.save();
        canvasCtx.beginPath();
        canvasCtx.rect(face.x, face.y, face.w, face.h);
        canvasCtx.lineWidth = lineWidth;
        canvasCtx.strokeStyle = color;

        if (index === winnerIndex && !isRolling && isFrozen) {
          canvasCtx.shadowColor = "red";
          canvasCtx.shadowBlur = 20;
        }
        canvasCtx.stroke();
        canvasCtx.restore();
      });
    }

    // --- æŠ½çèˆ‡å‹•ç•«é‚è¼¯ ---
    drawBtn.addEventListener('click', () => {
      // è½‰æ› AI æ•¸æ“šç‚ºçµ±ä¸€æ ¼å¼ä¸¦èˆ‡æ‰‹å‹•æ•¸æ“šåˆä½µå„²å­˜
      const aiFacesFormatted = detectedFaces.map(d => {
         return d; // AI åŸå§‹æ•¸æ“šä¿ç•™ boundingBox ä¾›å¾ŒçºŒè¨ˆç®—
      });
      // æ‰‹å‹•æ•¸æ“šç›´æ¥ç”¨
      const allFaces = [...aiFacesFormatted, ...manualFaces];

      if (allFaces.length === 0) return;

      isFrozen = true;
      frozenFaces = allFaces;
      
      snapshotImage = new Image();
      snapshotImage.src = canvasElement.toDataURL();

      drawBtn.style.display = 'none';
      switchBtn.style.display = 'none'; 
      zoomArea.style.display = 'none'; 
      undoBtn.style.display = 'none'; 
      resetBtn.style.display = 'inline-block';
      statusText.innerText = "ğŸ”’ ç•«é¢å·²é–å®š | æŠ½çä¸­...";

      isRolling = true;
      winnerDisplay.innerText = "ğŸ² å‘½é‹è¼ªè½‰ä¸­...";
      winnerIndex = -1;
      
      let rollCount = 0;
      const maxRolls = 30;
      const speed = 80;

      const interval = setInterval(() => {
        winnerIndex = Math.floor(Math.random() * frozenFaces.length);
        rollCount++;
        if (rollCount >= maxRolls) {
          clearInterval(interval);
          finishLottery();
        }
      }, speed);
    });

    function finishLottery() {
      isRolling = false;
      winnerDisplay.innerText = "ğŸš€ ç¥ç®­ç™¼å°„ä¸­...";
      prepareArrow(); 
    }

    function prepareArrow() {
      const startCorner = Math.random() > 0.5 ? 0 : canvasElement.width;
      arrowStart = { x: startCorner, y: 0 };
      
      const targetFace = frozenFaces[winnerIndex];
      let tx, ty;

      // åˆ¤æ–·æ˜¯ AI æ•¸æ“šé‚„æ˜¯æ‰‹å‹•æ•¸æ“šï¼Œå–å¾—ä¸­å¿ƒé»
      if (targetFace.boundingBox) {
          tx = targetFace.boundingBox.xCenter * canvasElement.width;
          ty = targetFace.boundingBox.yCenter * canvasElement.height;
      } else {
          tx = targetFace.x + targetFace.w / 2;
          ty = targetFace.y + targetFace.h / 2;
      }
      
      arrowTarget = { x: tx, y: ty };
      isShooting = true;
      arrowProgress = 0;
      explosionFrame = 0;
    }

    function updateAndDrawArrow() {
      if (arrowProgress < 1) {
        arrowProgress += 0.04; 
      } else {
        explosionFrame++;
        if (explosionFrame > 15) {
           isShooting = false; 
           showWinnerDetail(winnerIndex); 
           return;
        }
      }

      const curX = arrowStart.x + (arrowTarget.x - arrowStart.x) * Math.min(arrowProgress, 1);
      const curY = arrowStart.y + (arrowTarget.y - arrowStart.y) * Math.min(arrowProgress, 1);
      const angle = Math.atan2(arrowTarget.y - arrowStart.y, arrowTarget.x - arrowStart.x);

      if (arrowProgress <= 1) {
        drawMagicArrow(curX, curY, angle);
      }
      
      if (arrowProgress >= 1) {
        drawExplosion(arrowTarget.x, arrowTarget.y, explosionFrame);
      }
    }

    // ... ç¹ªåœ–è¼”åŠ©å‡½å¼ (ç®­é ­ã€çˆ†ç‚¸ã€é‡ç½®...) èˆ‡ä¹‹å‰ç›¸åŒ ...
    function drawMagicArrow(x, y, angle) {
      canvasCtx.save();
      canvasCtx.translate(x, y);
      canvasCtx.rotate(angle);
      canvasCtx.shadowColor = "#FFD700";
      canvasCtx.shadowBlur = 15;
      canvasCtx.beginPath();
      canvasCtx.moveTo(-40, 0);
      canvasCtx.lineTo(20, 0);
      canvasCtx.lineWidth = 6;
      canvasCtx.strokeStyle = "white";
      canvasCtx.stroke();
      canvasCtx.beginPath();
      canvasCtx.moveTo(20, -10);
      canvasCtx.lineTo(40, 0);
      canvasCtx.lineTo(20, 10);
      canvasCtx.fillStyle = "#FFD700";
      canvasCtx.fill();
      canvasCtx.restore();
    }

    function drawExplosion(x, y, frame) {
      canvasCtx.save();
      canvasCtx.translate(x, y);
      const radius = frame * 5; 
      const alpha = 1 - (frame / 15); 
      canvasCtx.beginPath();
      canvasCtx.arc(0, 0, radius, 0, Math.PI * 2);
      canvasCtx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
      canvasCtx.fill();
      canvasCtx.restore();
    }

    function showWinnerDetail(index) {
      if (index < 0 || index >= frozenFaces.length) return;
      winnerDisplay.innerText = "âœ¨âœ¨ å¤©é¸ä¹‹äººèª•ç”Ÿï¼ âœ¨âœ¨";
      
      const face = frozenFaces[index];
      let x, y, w, h;
      
      if (face.boundingBox) {
          w = face.boundingBox.width * canvasElement.width;
          h = face.boundingBox.height * canvasElement.height;
          x = face.boundingBox.xCenter * canvasElement.width - w/2;
          y = face.boundingBox.yCenter * canvasElement.height - h/2;
      } else {
          x = face.x; y = face.y; w = face.w; h = face.h;
      }

      const padding = 0.5;
      const extW = w * (1 + padding);
      const extH = h * (1 + padding);
      const extX = x - (w * padding) / 2;
      const extY = y - (h * padding) / 2;

      const targetW = 300;
      const targetH = targetW * (h / w);
      winnerCanvas.width = targetW;
      winnerCanvas.height = targetH;
      
      winnerCtx.drawImage(snapshotImage, extX, extY, extW, extH, 0, 0, targetW, targetH);
      winnerModal.style.display = 'flex';
    }

    resetBtn.addEventListener('click', () => {
      isFrozen = false;
      isRolling = false;
      isShooting = false;
      winnerIndex = -1;
      frozenFaces = [];
      manualFaces = []; 
      snapshotImage = null;
      winnerDisplay.innerText = "";
      
      drawBtn.style.display = 'inline-block';
      drawBtn.disabled = false; 
      switchBtn.style.display = 'inline-block';
      undoBtn.style.display = 'none'; 
      if (zoomCap) zoomArea.style.display = 'flex';
      resetBtn.style.display = 'none';
      closeModal();
      statusText.innerText = "å·²é‡ç½® | åµæ¸¬ä¸­...";
    });

    function closeModal() {
      winnerModal.style.display = 'none';
    }

    startBtn.addEventListener('click', startCamera);
    switchBtn.addEventListener('click', () => {
      useFrontCamera = !useFrontCamera;
      startCamera();
    });
  </script>
</body>

</html>
